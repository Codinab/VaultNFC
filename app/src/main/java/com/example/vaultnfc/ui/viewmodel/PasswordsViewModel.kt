import android.util.Base64
import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.vaultnfc.data.repository.FirebaseRepository
import com.example.vaultnfc.model.PasswordItem
import kotlinx.coroutines.launch
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec

class PasswordsViewModel : ViewModel() {
    private val _passwordsList = MutableLiveData<List<PasswordItem>>()
    val passwordsList: LiveData<List<PasswordItem>> = _passwordsList

    private val firebaseRepository = FirebaseRepository() // Instance of FirebaseRepository

    init {
        fetchPasswords()
    }

    private fun fetchPasswords() {
        viewModelScope.launch {
            try {
                val fetchedPasswords = firebaseRepository.getAllPasswords()
                _passwordsList.value = fetchedPasswords
                Log.d("PasswordsViewModel", "Updating passwords")
            } catch (e: Exception) {
                Log.e("PasswordsViewModel", "Error fetching passwords", e)
            }
        }
    }

    fun addPassword(
        title: String,
        username: String,
        rawPassword: String,
        uri: String,
        notes: String,
    ) {
        viewModelScope.launch {
            try {
                // Encrypt the password before storing it
                val encryptedPassword = encryptPassword(rawPassword, "Test")
                val encryptionIV = generateEncryptionIV() // Your method to generate an IV
                val passwordItem = PasswordItem(
                    id = "", // ID should be generated by Firebase
                    title = title,
                    username = username,
                    encryptedPassword = encryptedPassword,
                    uri = uri,
                    notes = notes,
                    encryptionIV = encryptionIV
                )
                firebaseRepository.addPassword(passwordItem)
                // After adding, fetch the latest list to update the local list
                fetchPasswords()
            } catch (e: Exception) {
                // Handle exceptions
            }
        }
    }

    // SecureRandom for IV generation
    private val secureRandom = SecureRandom()

    // Placeholder for your encryption method
    fun encryptPassword(password: String, masterPassword: String): String {
        val secretKey = deriveKeyFromPassword(masterPassword)
        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        val ivBytes = ByteArray(cipher.blockSize)
        secureRandom.nextBytes(ivBytes)
        val ivSpec = IvParameterSpec(ivBytes)
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec)
        val encryptedBytes = cipher.doFinal(password.toByteArray(Charsets.UTF_8))
        val ivAndEncrypted = ivBytes + encryptedBytes
        return Base64.encodeToString(ivAndEncrypted, Base64.DEFAULT)
    }

    // Placeholder for your decryption method
    fun decryptPassword(encryptedData: String, masterPassword: String): String {
        val ivAndEncryptedBytes = Base64.decode(encryptedData, Base64.DEFAULT)
        val secretKey = deriveKeyFromPassword(masterPassword)
        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        val ivBytes = ivAndEncryptedBytes.copyOfRange(0, cipher.blockSize)
        val encryptedBytes =
            ivAndEncryptedBytes.copyOfRange(cipher.blockSize, ivAndEncryptedBytes.size)
        val ivSpec = IvParameterSpec(ivBytes)
        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
        val decryptedBytes = cipher.doFinal(encryptedBytes)
        return String(decryptedBytes, Charsets.UTF_8)
    }

    // Method to derive a SecretKeySpec from a password
    fun deriveKeyFromPassword(password: String): SecretKeySpec {
        val salt =
            ByteArray(16) // Consider a secure way to generate and store a unique salt per user
        val iterationCount = 10000
        val keyLength = 256
        val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
        val spec = PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength)
        val tmp = factory.generateSecret(spec)
        val secretKey = SecretKeySpec(tmp.encoded, "AES")
        return secretKey
    }

    // Placeholder for your method to generate an IV
    private fun generateEncryptionIV(): String {
        // Implement IV generation logic here
        return "IV" // Return the generated IV
    }

    fun removePassword(passwordItem: PasswordItem) {
        viewModelScope.launch {
            try {
                firebaseRepository.removePassword(passwordItem.id)
                // Refresh the list after removal
                fetchPasswords()

                Log.d("PasswordsViewModel", "Removed password: ${passwordItem.title}")
            } catch (e: Exception) {
                Log.e("PasswordsViewModel", "Error removing password", e)
            }
        }
    }


}
